function_type;description;function_mysql;argument_func_mysql;function_postgresql;argument_func_postgresql;returns;detailed_description;examples_mysql;examples_postgresql;replacing
текстовые;объединяет значения;CONCAT();значения или поля через запятую;CONCAT() или ||;значения или поля через запятую;строка;"Принимает переменное количество аргументов, выполняет их конкатенацию и возвращает полученный результат. Результатом функции всегда является строка, однако аргументы функции могут принадлежать любым типам, поскольку функция неявно преобразует все аргументы в строки перед объединением.";"SELECT CONCAT(artist, ' - ', trackname)";Select 'Post' || 'greSQL' > PostgreSQL;
текстовые;объединяет значения через разделитель;CONCAT_WS();"'разделитель', знач1, ..., значn";"CONCAT_WS(); ARRAY_TO_STRING(array['a', 'b', 's'], '--');";"'разделитель', знач1, ..., значn";строка;"Объединяет значения и добавляет между ними разделитель. Разделитель указывается в качестве первого аргумента, объединяемые значения — в качестве всех остальных. Перед объединением неявно преобразует все аргументы в строки";"SELECT CONCAT_WS(', ', id, artist, trackname)";"ARRAY_TO_STRING(array['a', 'b', 's'], '--');";
текстовые;длина строки;CHAR_LENGTH();строка;"CHAR_LENGTH(), LENGTH()";строка;число;принимает в качестве аргумента строку и возвращает количество символов в ней.  При вызове с аргументом NULL возвращают значение NULL.;SELECT CHAR_LENGTH('beegeek');;
текстовые;перевод в нижний регистр;LOWER();строка;LOWER();строка;строка;используется для перевода строки в нижний регистр. При вызове с аргументом NULL возвращают значение NULL.;SELECT LOWER('beegeek');;
текстовые;перевод в верхний регистр;UPPER() ;строка;UPPER() ;строка;строка;используется для перевода строки в верхний регистр. При вызове с аргументом NULL возвращают значение NULL.;SELECT  LOWER('BEEGEEK');;
текстовые;убирает пробелы слева;LTRIM() ;строка;LTRIM() ;строка;строка;убирает пробелы слева. При вызове с аргументом NULL возвращают значение NULL.;SELECT LTRIM(' bee');;
текстовые;убирает пробелы справа;RTRIM();строка;RTRIM();строка;строка;убирает пробелы справа. При вызове с аргументом NULL возвращают значение NULL.;;;
текстовые;переворачивает строку ;REVERSE() ;строка;REVERSE() ;строка;строка;переворачивает строку (можно с числовыми). При вызове с аргументом NULL возвращают значение NULL.;;;
текстовые;повторяет;REPEAT();"строка, сколько раз повторить";REPEAT();"строка, сколько раз повторить";строка;"повторяет строку (можно с числовыми)ю Если количество повторов меньше 1, то функция REPEAT() вернет пустую строку.  При вызове с аргументом NULL возвращают значение NULL.";;;
текстовые;добавить слева;LPAD() ;"исх_строка, желаемая_длина_строки, чем_дополнить";LPAD() ;"исх_строка, желаемая_длина_строки, чем_дополнить";строка;"используется для увеличения длины строки до определенного значения путем добавления в ее начало другой строки (можно с числовыми). Если длина исходной строки после добавления в ее начало дополняющей строки превышает желаемую длину, то функция LPAD() сокращает дополняющую строку путем отбрасывания правых символов. 
При вызове с аргументом NULL возвращают значение NULL.";"SELECT LPAD('bee', 2, '-'),  LPAD(REVERSE(artist), 20, '!')";;CONCAT()
текстовые;добавить справа;RPAD() ;"исх_строка, желаемая_длина_строки, чем_дополнить";RPAD() ;"исх_строка, желаемая_длина_строки, чем_дополнить";строка;"используется для увеличения длины строки до определенного значения путем добавления другой строки справа(можно с числовыми). Если длина исходной строки после добавления справа дополняющей строки превышает желаемую длину, то функция LPAD() сокращает дополняющую строку путем отбрасывания правых символов. При вызове с аргументом NULL возвращают значение NULL.";"SELECT RPAD('bee', 7, '-+')";;CONCAT()
текстовые;извлеч из начала строки;LEFT();"исх_строка, кол-во извлекаемых символов";LEFT();"исх_строка, кол-во извлекаемых символов";строка;"извлечения определенного количества символов из начала строки. Если количество извлекаемых символов меньше 1, функция LEFT() вернет пустую строку.  ";"SELECT LEFT('beegeek', 3)";;SUBSTRING()
текстовые;извлеч из конца строки;RIGHT();"исх_строка, кол-во извлекаемых символов";RIGHT();"исх_строка, кол-во извлекаемых символов";строка;"извлечения определенного количества символов из конца строки. Если количество извлекаемых символов меньше 1, функция вернет пустую строку.  ";;;SUBSTRING()
текстовые;местоположения подстроки в строке;LOCATE();"искомая_подстрокаб, исходная_строка, позиция_начала_поиска ";POSITION('a' in string);"искомая_подстрокаб, исходная_строка, позиция_начала_поиска ";число;"определения местоположения подстроки в строке. Позиция начала поиска (может не указываться, в таком случае поиск выполняется с начала строки) . Если искомой подстроки в строке нет, функция LOCATE() вернет значение 0. выполняет поиск позиции подстроки без учета регистра.  символы исходной строки нумеруются с 1, а не с 0.  ";"SELECT LOCATE('e', 'beegeek'),        LOCATE('g', 'beegeek'),        LOCATE('eg', 'beegeek'),";;"LEFT(), RIGHT() "
текстовые;замена подстроки в строке;REPLACE();"исходная_строка, заменяемая_подстрока, заменяющая_подстрока";REPLACE();"исходная_строка, заменяемая_подстрока, заменяющая_подстрока";строка;"замены подстроки в строке. Если заменяемой подстроки в строке нет, функция REPLACE() вернет строку в исходном виде. выполняет замену с учетом регистра.  ";"SELECT REPLACE('beegeek', 'e', 'i')";;TRIM()
текстовые;извлечения подстроки из строки;SUBSTRING();"исходная_строка, позиция_первого_извлекаемого_символа, длина_извлекаемой_ подстроки";SUBSTR() или SUBSTRING(исходная_строка FROM начало(паттерн) FOR сколько_символов ) или ;"исходная_строка, позиция_первого_извлекаемого_символа, длина_извлекаемой_ подстроки";строка;"извлечения подстроки из строки. длина извлекаемой подстроки (может не указываться, в таком случае подстрока извлекается до конца) . символы исходной строки нумеруются с 1, а не с 0. Позиция первого извлекаемого символа может быть отрицательным числом, в таком случае символы нумеруются с конца. Последнему символу соответствует позиция -1, предпоследнему — -2, и так далее.  ";"SELECT SUBSTRING('beegeek', 1),        SUBSTRING('beegeek', -4),        SUBSTRING('beegeek', 4, 2)";"substring('Thomas' from 2 for 3) > hom ;     substring('Thomas' from 3) > omas;      substring('Thomas' for 2) > Th;     substring('Thomas' from '...$') > mas";
текстовые;извлечения подстроки с помощью разделителя;SUBSTRING_INDEX();"исходная_строка, разделитель, количество_появлений_ разделителя";SPLIT_PART();"исходная_строка, разделитель, количество_появлений_ разделителя";строка;"извлечения подстроки из строки с помощью разделителя. Количество появлений разделителя может быть отрицательным числом, в таком случае извлечение подстроки происходит с конца.";"SELECT SUBSTRING_INDEX('g-e-e-k', '-', 1)     ----    g ,        SUBSTRING_INDEX('g-e-e-k', '-', 2)     -----   g-e ,";;
текстовые;удаления всех вхождений подстроки;TRIM();"TRIM(<ключевое слово LEADING, TRAILING или BOTH> <удаляемая подстрока> FROM <исходная строка>) ";TRIM();"TRIM(<ключевое слово LEADING, TRAILING или BOTH> <удаляемая подстрока> FROM <исходная строка>) ";строка;"удаления всех вхождений подстроки из начала и/или конца строки. Ключевые слова LEADING, TRAILING и BOTH могут не указываться, в таком случае удаление подстроки происходит из начала и конца строки. Удаляемая подстрока также может быть опущена, в таком случае ею считается пробел.  Если не указаны и ключевое слово, и удаляемая подстрока, функция TRIM() выполнит удаление всех пробелов из начала и конца строки.  ";"SELECT TRIM(LEADING '-' FROM '--bee--'),        TRIM(TRAILING '-' FROM '--bee--'),        TRIM(BOTH '-' FROM '--bee--');";;REPLACE()
числовые;модуль;ABS();число;ABS();число;число;вычисления модуля числа;"SELECT ABS(-1),        ABS(-2.1234)";"SELECT ABS(-1),  -- 1       ABS(-2.1234)  -- 2.1234";
числовые;округление;ROUND();"число, количество знаков после запятой";ROUND();"число, количество знаков после запятой";число;"возвращает число, округленное до указанных знаков после запятой.  округляет число согласно математическим правилам округления, то есть в большую по модулю сторону. Количество знаков после запятой может быть не указано, в таком случае функция ROUND() выполнит округление до целого числа.";"SELECT ROUND(23.165, 2)";;
числовые;возведение в степень;POW();"число, степень";POWER();"число, степень";число;"возвращает число, возведенное в указанную степень.";"SELECT POW(2, 3)";;
числовые;корень;SQRT();число;SQRT();число;число;вычисления квадратного корня.;"SELECT SQRT(0),        SQRT(9),        SQRT(20);";;
числовые;генератор случ. Чисел;RAND();начальное значение(необязательно);RANDOM();начальное значение(необязательно);число;"генерация случайных чисел. При вызове без аргументов она возвращает случайное число с плавающей точкой в диапазоне [0, 1). С одним и тем же аргументом функция будет возвращать одно и то же случайное число.  ";"SELECT * FROM SQLTeam ORDER BY RAND() LIMIT 2; -- извлечение случайных записей из таблицы";;
числовые;округление в меньшую сторону;FLOOR();число;FLOOR();число;число;округление в меньшую сторону до целого;;;
числовые;округление в большую сторону;CEILING();число;CEILING();число;число;округление в большую сторону до целого;;;
числовые;из радиан в градусы;DEGREES();значение в радианах;DEGREES();значение в радианах;число;"перевода значения из радиан в градусы. Она принимает в качестве аргумента значение в радианах, конвертирует его в градусы и возвращает полученный результат.";SELECT DEGREES(1)    -----  57.29577951308232;;
числовые;градусы в радианы;RADIANS();значение в градусах;RADIANS();значение в градусах;число;перевод — из градусов в радианы.;SELECT  RADIANS(180)     -----    3.141592653589793;;
числовые;синус;SIN();число в радианах;SIN();число в радианах;число; принимает в качестве аргумента значение в радианах и возвращает соответствующую тригонометрическую величину.;;;
числовые;косинус;COS();число в радианах;COS();число в радианах;число; принимает в качестве аргумента значение в радианах и возвращает соответствующую тригонометрическую величину.;;;
числовые;тангенс;TAN();число в радианах;TAN();число в радианах;число; принимает в качестве аргумента значение в радианах и возвращает соответствующую тригонометрическую величину.;;;
числовые;наименьшее;LEAST();аргументы;LEAST();аргументы;число;"принимает переменное количество аргументов (не меньше двух) и возвращает наименьший из них.   Если поиск минимального значения происходит среди действительных (типы FLOAT и DOUBLE) и целых чисел, функция LEAST() сначала преобразует все числа в действительные.  Если хотя бы один из аргументов, переданных в функцию LEAST(), является строкой, функция перед поиском минимального значения сначала преобразует все аргументы в строки.  Если хотя бы один из аргументов, переданных в функцию LEAST(), равняется NULL, возвращаемым значением функции также будет NULL.  ";"SELECT LEAST(2, 1, 3, 5, 4)    ----   1";;
числовые;наибольшее;GREATEST();аргументы;GREATEST();аргументы;число;выполняет поиск наибольшего значения. ;;;
числовые;перевод в с-му исчисления;CONV();"число, система счисления (в которой представлено число), система счисления (в которую нужно перевести число)";CONV();"число, система счисления (в которой представлено число), система счисления (в которую нужно перевести число)";число;перевода числа из одной системы счисления в другую. ;"SELECT CONV(5, 10, 2)    ----    101";;
числовые;округление и форматирование;FORMAT();"число, кол-во знаков после запятой";;"число, кол-во знаков после запятой";число;"округляет число num до decimals знаков после запятой, форматирует его путем разбиения на разряды и возвращает полученный результат в виде строки.  Если указанное количество знаков после запятой больше фактического количества знаков у числа, функция FORMAT() заполнит недостающие знаки незначащими нулями.";"SELECT FORMAT(1000000.1653, 3)     -----  1,000,000.165 ";;
дата и время;текущая дата и время;NOW();;NOW();;дата и время;не принимает никаких аргументов и возвращает текущую дату и время в локальном часовом поясе;"SELECT NOW(); ";;
дата и время;текущая дата  ;CURDATE();;CURRENT_DATE;;дата ;текущая дата  ;;;
дата и время;текущее время;CURTIME();;CURRENT_TIME;;время;текущее время;;;
дата и время;текущая дата и время по UTS;UTC_TIMESTAMP();;;;дата и время;"не принимает никаких аргументов и возвращает текущую дату и время в UTC, то есть в нулевом часовом поясе.";;;
дата и время;текущая дата по UTS    ;UTC_DATE();;;;дата ;текущая дата по UTS    ;;;
дата и время;текущее время по UTS    ;UTC_TIME();;;;время;текущее время по UTS    ;;;
дата и время;создание даты;MAKEDATE();"год, номер дня в году";MAKEDATE();"год, номер месяца, число";дата ;"возвращает дату, которая имеет порядковый номер day в году year.  Если хотя бы один из аргументов, переданных в функции MAKEDATE() и MAKETIME(), являeтся значением NULL, функции вернут значение NULL.";"SELECT MAKEDATE(2023, 1),        MAKEDATE(2023, 255),        MAKEDATE(2023, 365);";;
дата и время;создание временного значения;MAKETIME();"часы, минуты, секунды";MAKETIME();"часы, минуты, секунды";время;"возвращает временное значение, состоящее из часов, минут и секунд.  Если хотя бы один из аргументов, переданных в функции MAKEDATE() и MAKETIME(), являeтся значением NULL, функции вернут значение NULL.";"SELECT MAKETIME(12, 33, 1),        MAKETIME(0, 1, 2),        MAKETIME(21, 11, 42);   ";;
дата и время;время в секунды;TIME_TO_SEC();временное значение; ;временное значение;число;"принимает в качестве аргумента временное значение, преобразует его в количество секунд. при вызове с аргументом NULL возвращают значение NULL.  ";"SELECT TIME_TO_SEC('00:00:25'),        TIME_TO_SEC('00:01:30'),        TIME_TO_SEC('01:00:00');";;
дата и время;Кол-во секунд во время;SEC_TO_TIME();Кол-во секунд; ;Кол-во секунд;время;преобразование количества секунд во временное значение. при вызове с аргументом NULL возвращают значение NULL.  ;"SELECT SEC_TO_TIME(25),        SEC_TO_TIME(90),        SEC_TO_TIME(3600);";;
дата и время;дата в кол-во дней;TO_DAYS();дата;;дата;число;"принимает в качестве аргумента дату, преобразует ее в количество дней. отсчет количества дней начинается с нулевого года. при вызове с аргументом NULL возвращают значение NULL.  ";"SELECT TO_DAYS('2023-04-01'),        TO_DAYS('0001-01-01'),        TO_DAYS('0000-01-01');";;
дата и время;дата в кол-во секунд;TO_SECONDS();дата;;дата;число;преобразует дату в количество секунд.  при вызове с аргументом NULL возвращают значение NULL.  ;;;
дата и время;последний день месяца;LAST_DAY();дата;"(date_trunc('month', now()) + interval '1 month - 1 day')::date";дата;дата ;"принимает в качестве аргумента дату, заменяет в ней день на последний день месяца этой даты.  при вызове с аргументом NULL возвращают значение NULL.  ";;;
дата и время;дата  ;DATE();дата и время;DATE();"что извлечь, дата и время";дата ;"принимает в качестве аргумента дату и время, извлекает из него дату и возвращает полученный результат. Если аргументом функции DATE() является дата без времени, функция вернет ее в исходном виде.  ";SELECT DATE('2023-10-20 12:30:00')    ---- 2023-10-20 ;;
дата и время;время;TIME();дата и время;CAST();‘строка’\дата-время AS TIME;время;"принимает в качестве аргумента дату и время, извлекает из него время и возвращает полученный результат. Если аргументом функции является время без даты, функция вернет ее в исходном виде.  ";;select cast('2024-10-09 10:11:12' as time);
дата и время;Кол-во часов;HOUR();время;DATE_PART();"'hour', строка или дата\время ";число;"определения количества часов во времени. Она принимает в качестве аргумента временное значение, извлекает из него часы и возвращает полученный результат.";SELECT HOUR('12:30:10')    ---  12;"date_part('hour', TIMESTAMP '2024-10-09 10:11:12')   -----   10;     date_part('hour', NOW())";
дата и время;Кол-во минут;MINUTE();время;DATE_PART();"'minute’, строка или дата\время ";число;"принимает в качестве аргумента временное значение, извлекает из него минуты и возвращает полученный результат.";SELECT MINUTE('12:30:10.1415')   ---   30;"date_part('hour', TIMESTAMP '2024-10-09 10:11:12')   -----   10;     date_part('hour', NOW())";
дата и время;Кол-во секунд;SECOND();время;DATE_PART();"'second', строка или дата\время ";число;"принимает в качестве аргумента временное значение, извлекает из него секунды и возвращает полученный результат.";SELECT SECOND('12:30:10.1415')    ----  10;"date_part('hour', TIMESTAMP '2024-10-09 10:11:12')   -----   10;     date_part('hour', NOW())";
дата и время;Кол-во микросекунд;MICROSECOND();время;DATE_PART();"'microsecond', строка или дата\время ";число;"принимает в качестве аргумента временное значение, извлекает из него микросекунды и возвращает полученный результат.";SELECT MICROSECOND('12:30:10.1415')    ----  141500;"date_part('hour', TIMESTAMP '2024-10-09 10:11:12')   -----   10;     date_part('hour', NOW())";
дата и время;год;YEAR();дата;DATE_PART();"'year', строка или дата\время ";число;извлечения значения года из даты. ;SELECT YEAR('2023-10-26 12:30:10.1415')    ----  2023;"date_part('hour', TIMESTAMP '2024-10-09 10:11:12')   -----   10;     date_part('hour', NOW())";
дата и время;номер месяца;MONTH();дата;DATE_PART();"'month', строка или дата\время ";число;извлечения значения месяца из даты. ;SELECT MICROSECOND('12:30:10.1415')    ----  141500;"date_part('hour', TIMESTAMP '2024-10-09 10:11:12')   -----   10;     date_part('hour', NOW())";
дата и время;день;DAY();дата;DATE_PART();"'day', строка или дата\время ";число;извлечения значения дня из даты. ;SELECT DAY('12:30:10.1415')    ----  141500;"date_part('hour', TIMESTAMP '2024-10-09 10:11:12')   -----   10;     date_part('hour', NOW())";
дата и время;номер дня в году;DAYOFYEAR();дата;DATE_PART();"'doy', строка или дата\время ";число;вычисления номера дня в году (от 1 до 366) на основе даты.;SELECT DAYOFYEAR('2023-02-01')    ---32;"date_part('hour', TIMESTAMP '2024-10-09 10:11:12')   -----   10;     date_part('hour', NOW())";
дата и время;номер недели в году;WEEK();дата;DATE_PART();"'week', строка или дата\время ";число;вычисления номера недели в году на основе даты.;SELECT WEEK('2023-12-31')   ---  53;"date_part('hour', TIMESTAMP '2024-10-09 10:11:12')   -----   10;     date_part('hour', NOW())";
дата и время;номер дня недели;WEEKDAY();дата;DATE_PART();"'dow', строка или дата\время ";число;вычисления номера дня недели (от 0 до 6) на основе даты.;SELECT WEEKDAY('2023-10-16')   ---  0  (понедельник);"date_part('hour', TIMESTAMP '2024-10-09 10:11:12')   -----   10;     date_part('hour', NOW())";
дата и время;квартал;QUARTER();дата;DATE_PART();"'day', строка или дата\время ";число;вычисления номера квартала (от 1 до 4) на основе даты. ;;"date_part('hour', TIMESTAMP '2024-10-09 10:11:12')   -----   10;     date_part('hour', NOW())";
дата и время;день недели (англ);DAYNAME();дата;TO_CHAR();"дата/строка,  'day'/'dy'";строка;"принимает в качестве аргумента дату, определяет день недели, который соответствует переданной дате, и возвращает его полное название.";SELECT DAYNAME('2023-10-16')    ---- Monday;"to_char(TIMESTAMP '2024-10-09 10:11:12', 'dy')   ---  wed;   to_char(TIMESTAMP '2024-10-09 10:11:12', 'day')   ---  wednsday";
дата и время;название месяца (англ);MONTHNAME();дата;TO_CHAR();"дата/строка,  'month'/'mon’";строка;определения названия месяца на основе даты.;SELECT MONTHNAME('2023-01-01')    ----   January;"to_char(TIMESTAMP '2024-10-09 10:11:12', 'month')    ---  october;     to_char(TIMESTAMP '2024-10-09 10:11:12', 'MONTH')   ---   OCTOBER;  to_char(TIMESTAMP '2024-10-09 10:11:12', 'mon')     ----   oct";
дата и время;прибавления временного интервала;ADDDATE();"дата и время, временной интервал";timestamp  + INTERVAL  'кол-во  чего';дата и время + временной интервал;дата (+-время);прибавления временного интервала к дате и времени. ;"SELECT ADDDATE('2023-10-20 07:30:00', INTERVAL 4 DAY)";"timestamp '2023-10-26 07:30:00' + interval '4 day'   ---   2023-10-30 07:30:00.000;   NOW()  + interval '4 year'";
дата и время;вычитает временной интервал;SUBDATE();"дата и время, временной интервал";timestamp  + INTERVAL  'кол-во  чего';дата и время - временной интервал;дата (+-время);"вычитает временной интервал из даты и времени,";"SELECT SUBDATE('2023-10-20 07:30:00', INTERVAL 4 HOUR)";"timestamp '2023-10-26 07:30:00' - interval '4 hour'   ---   2023-10-26 03:30:00.000;   NOW()  - interval '4 year'";
дата и время;прибавляет время;ADDTIME();"дата и время (время), время";просто прибавить;дата и время (время) + время;время (± дата);прибавления временного значения к дате и времени.;"SELECT ADDTIME('2023-10-20 21:00:00', '02:00:00'),  ADDTIME('21:30:00', '08:30:00')";select timestamp '2017-10-10 12:11:10' + time '12:12'   ---   2017-10-11 00:23:10.000;
дата и время;отнимает время;SUBTIME();"дата и время (время), время";просто отнять;дата и время (время) -  время;время (± дата);"вычитает временное значение из даты и времени. Если первое временное значение, переданное в функцию SUBTIME(), меньше второго, функция вернет отрицательный результат.  ";"SELECT  SUBTIME('2023-10-20 21:00:00', '06:00:00'),        SUBTIME('20:40:00', '10:00:00'); ";timestamp '2023-10-26 07:30:00' - time '2:15';select timestamp '2017-10-10 12:11:10' - time '12:12'   ---   2017-10-09 23:59:10.000
дата и время;разница в днях;DATEDIFF();"1 дата и время (дата), 2 дата и время(дата)";"DATE_PART('day', timestamp '1' - timestamp '2'); ";"1 дата и время (дата), 2 дата и время(дата)";число;"вычисления разницы в днях между двумя значениями даты и времени. Если первая дата и время, переданная в функцию DATEDIFF(), меньше второй, функция вернет отрицательный результат.  При вычислении разницы функция DATEDIFF() использует только дату, время не используется";"SELECT DATEDIFF('2023-10-26 07:30:00', '2023-10-20 8:00:00')    ---   6";"select date_part('day', timestamp '2015-01-14 00:51:14' - timestamp '2015-01-11 00:51:14'); ";
дата и время;разница во времени;TIMEDIFF();"1 дата и время (время), 2 дата и время(время)";;"1 дата и время (время), 2 дата и время(время)";время;"вычисления разницы во времени между двумя значениями даты и времени.  Если первая дата и время, переданная в функцию TIMEDIFF(), меньше второй, функция вернет результат в виде отрицательного временного значения. ";"SELECT  TIMEDIFF('2023-10-25 9:00:00', '2023-10-20 07:00:00')    ----   122:00:00";;
дата и время;разница в единицах измерения;TIMESTAMPDIFF();"единица измерения (в которой требуется получить разницу),  1 дата и время (дата), 2 дата и время(дата)";EXTRACT (EPOCH from c.time_stamp — c2.time_stamp)::int;epoch from 1 дата и время (дата) — 2 дата и время(дата);число;"вычисления разницы между двумя значениями даты и времени в определенных единицах измерения. Если первое дата и время, переданное в функцию TIMESTAMPDIFF(), больше второго, функция вернет отрицательный результат.  Каждый из аргументов, передаваемых в функцию TIMESTAMPDIFF(), может быть как датой и временем, так и просто датой, при этом дата имеет нулевые значения по всем компонентам времени.";"SELECT TIMESTAMPDIFF(HOUR, '2023-10-20 07:00:00', '2023-10-20 12:00:00') AS hours     ----  5";EXTRACT (EPOCH from c.time_stamp — c2.time_stamp)::int    в секундах (/60 - в минутах);
дата и время;обьединение даты и времени;TIMESTAMP();"дата, время";date 'значение' + time 'значение';"дата, время";дата и время;"объединения даты и временного значения. Функция TIMESTAMP() автоматически конвертирует каждые 24 часа в 1 день.  Временное значение может не указываться, в таком случае оно будет принято равным 00:00:00.";"SELECT TIMESTAMP('2023-10-20', '28:00')   ---- 2023-10-21 04:00:00";select date '2015-01-21' + time '18:00'    ----   2015-01-21 18:00:00.000;
дата и время;форматирования даты и времени;DATE_FORMAT();"дата и время (дата), строка формата";;"дата и время (дата), строка формата";строка;"форматирования даты и времени. в качестве первого аргумента может принимать не только дату и время, но и просто дату. Во втором случае считается, что дата имеет нулевые значения по всем компонентам времени.";"SELECT DATE_FORMAT('2023-10-20 07:30:00', '%H:%i, %d.%m.%Y')    ----   07:30, 20.10.2023";;
дата и время;форматирование времени;TIME_FORMAT();"временное значение, строка формата";;"временное значение, строка формата";строка;форматирование времени ;"SELECT TIME_FORMAT('12:30:00', 'Time: %H:%i')     -----   Time: 12:30 ";;
дата и время;строка в дату ;STR_TO_DATE();"строка с компонентами даты и времени, строка формата";"TO_DATE(), T0_TIMESTAMP()";"строка с компонентами даты и времени, строка формата";дата (+-время);"Функция извлекает из строки string компоненты даты и времени в соответствии с форматом format и возвращает дату и время на основе извлеченных компонентов. Если в строке с компонентами представлены только компоненты даты, функция STR_TO_DATE() вернет дату без времени, если только компоненты времени — время без даты.  При этом для создания даты или даты и времени должны быть определены все компоненты даты (год, месяц, число), и если хотя бы один компонент пропущен, функция вернет значение NULL. В случае с временным значением достаточно одного любого компонента, остальные по умолчанию примут значение 0.  Во время использования функции STR_TO_DATE() необходимо следить за тем, чтобы строка с компонентами даты и времени полностью соответствовала строке формата, в противном случае функция вернет значение NULL.";"SELECT STR_TO_DATE('07:30, 20.10.2023', '%H:%i, %d.%m.%Y')     -----    2023-10-20 07:30:00";"SELECT TO_DATE('20170103','YYYYMMDD')   ---   2017-01-03;   TO_DATE('10 Feb 2017', 'DD Mon YYYY')    ----    2017-02-10;";
дата и время;получение формата;GET_FORMAT();"тип объекта, для которого требуется строка формата (DATE, TIME или DATETIME), непосредственно формат (USA, JIS, ISO или EUR)";;"тип объекта, для которого требуется строка формата (DATE, TIME или DATETIME), непосредственно формат (USA, JIS, ISO или EUR)";формат;"получения определенной строки формата для даты, времени или даты и времени. ";"SELECT GET_FORMAT(DATETIME, 'EUR')    ----   %Y-%m-%d %H.%i.%s";;
дополнительные;проверка на NULL;ISNULL();значение;'значение' IS NULL;значение;1 или 0;"принимает в качестве аргумента произвольное значение и возвращает 1, если переданным значением является NULL, или 0 в противном случае.";"SELECT ISNULL(0)   ---   0,        ISNULL(NULL)       -----    1;";"SELECT  '1' IS null   ---  false;     SELECT ROW(table.*) IS NULL FROM table;";
дополнительные;условие - 2 значения;IF();"условное выражение, значение1, значение2";условные конструкции;"условное выражение, значение1, значение2";значение;"используется для выбора одного из двух значений в зависимости от результата некоторого условного выражения. возвращает значение1, если условное выражение истинно, или значение2 в противном случае.";"SELECT IF(1 > 0, 'bee', 'geek')     ----    bee";case when '20' > '18' then '1' else '2' end;
дополнительные;первый не NULL из списка значений;COALESCE();аргументы ч-з запятую;COALESCE();аргументы ч-з запятую;значение;"поиск первого непустого значения. Она принимает переменное количество аргументов и возвращает первый из них, не равный NULL.";"SELECT COALESCE(1, 2, 3)   ---   1,        COALESCE(NULL, 2, 3)   ---   2,        COALESCE(1, NULL, 3)    ---   1";;
дополнительные;меняет NULL на значение;IFNULL();"исходное проверяемое значение, альтернативное значение";COALESCE();аргументы ч-з запятую;значение;"замена некоторого значения на альтернативное, если исходное значение равняется NULL.  возвращает значение value, если оно не равняется NULL, или значение alternative_value в противном случае.";"SELECT IFNULL(NULL, 'geek')    ----    geek,        IFNULL('bee', 'geek')    ----    bee";;COALESCE()
дополнительные;Сравнивает 2 значения;NULLIF();"значение1, значение2";NULLIF();"значение1, значение2";NULL или значение;"сравнение двух значений.  возвращает значение NULL, если значения value1 и value2 совпадают, или значение value1 в противном случае.  ";"SELECT NULLIF('bee', 'bee')     ----    NULL,        NULLIF('bee', 'geek')    ----    bee";;
дополнительные;конвертация типов данных;CONVERT();"значения (кот нужно преобразовать), тип";;"значения (кот нужно преобразовать), тип";значение;"Функция приводит значение value к типу type и возвращает полученный результат.  Значение, приводимое к определенному типу, должно соответствовать формату этого типа, в противном случае функция CONVERT() вернет значение NULL.  Однако при попытке привести несоответствующее формату значение к числовому типу функция CONVERT() вернет значение 0.  ";"SELECT CONVERT(100.78, DECIMAL(4, 1))   ---   100.8,   SELECT CONVERT CONVERT('beegeek', DATE)   ---   NULL,    SELECT CONVERT('beegeek', SIGNED)   ---   0";;
дополнительные;условные конструкции — значения;CASE;набор условных конструкций;CASE;набор условных конструкций;значение;проверку нескольких условий и в зависимости от истинности одного из них вернуть соответствующее значение. ;"SELECT title, author,        UPPER(CASE 
                                                               WHEN price < 5 THEN 'Cheap'  
                                                               WHEN price BETWEEN 5 AND 15 THEN 'Regular' 
                                                               ELSE 'Expensive' 
                                                               END) AS rate FROM Books;
                                ORDER BY CASE              WHEN title LIKE 'The %' THEN 1              ELSE 2          END;";;
дополнительные;порядковый номер из списка;FIELD();"поле, аргументы для сравнения ч-з запятую";;"поле, аргументы для сравнения ч-з запятую";число;"возвращает индекс одного из аргументов (начиная со второго аргумента, который имеет индекс 1) при совпадении первого аргумента с ним, или 0 при отсутствии совпадений.";"ORDER BY FIELD(status, 'Basic', 'Bronze', 'Silver', 'Gold') DESC, name ";;
агрегатные;среднее арифметическое ;AVG();поле (набор значений);AVG();поле (набор значений);число;"вычисления среднего арифметического числовых значений поля.  игнорирует значения NULL при вычислении среднего арифметического значений поля. можно использовать ключевое слово DISTINCT, чтобы в итоговых вычислениях участвовали лишь уникальные значения поля. возвращают значение 0.0, если применяются к нечисловым полям.";"SELECT AVG(streams) AS avg_streams FROM Songs WHERE release_year >= 2000;";;
агрегатные;Кол-во записей;COUNT();* для опр кол-ва записей (поле для опр кол-ва значений);COUNT();* для опр кол-ва записей (поле для опр кол-ва значений);число;"подсчета количества записей в таблице или количества значений в поле.  Для определения количества значений в поле функции COUNT() в качестве аргумента необходимо передать это поле.  Для определения количества записей в таблице в функцию COUNT() в качестве аргумента необходимо передать звездочку (*).    Важным отличием между вызовами COUNT(*) и COUNT(<название поля>) является то, что в первом случае возвращается количество записей в таблице без учета значений в этих записях, в то время как во втором случае возвращается количество значений в поле, причем значения NULL не учитываются.  можно использовать ключевое слово DISTINCT, чтобы в итоговых вычислениях участвовали лишь уникальные значения поля  ";"SELECT COUNT(*) AS num_of_songs,        COUNT(release_year) AS num_of_years FROM Songs;";;
агрегатные;минимальное значение;MIN();поле;MIN();поле;значение;поиска минимального значений в поле. игнорируют значения NULL при вычислении. применяется и к строковым полям.;;;
агрегатные;максимальное значение;MAX();поле;MAX();поле;значение;поиска ммаксимального значений в поле. игнорируют значения NULL при вычислении. применяется и к строковым полям.;;;
агрегатные;сумма;SUM();поле;SUM();поле;число;"вычисления суммы числовых значений поля.  игнорирует значения NULL.  можно использовать ключевое слово DISTINCT, чтобы в итоговых вычислениях участвовали лишь уникальные значения поля. возвращают значение 0.0, если применяются к нечисловым полям.";;;
агрегатные;перечисления значений поля;GROUP_CONCAT();поле;STRING_AGG();"поле, разделитель";значения;"перечисления значений поля через запятую. Перечисляемые функцией GROUP_CONCAT() значения можно сортировать.  Запятая является разделителем по умолчанию, и его можно изменить. Чтобы задать собственный разделитель, необходимо воспользоваться ключевым словом SEPARATOR, после которого предоставить строку, содержащую разделитель. игнорирует значения NULL.  можно использовать ключевое слово DISTINCT, чтобы в итоговых вычислениях участвовали лишь уникальные значения поля";"SELECT GROUP_CONCAT(trackname ORDER BY trackname SEPARATOR '; ') AS songs FROM Songs WHERE id <= 5;";"select string_agg(name, '-')";STRING_AGG()
ранжирующие;порядковый номер записи в рамках указанного окна (начиная с 1);ROW_NUMBER();;ROW_NUMBER();;число;"вычисляет порядковый номер записи в рамках указанного окна (начиная с 1). ORDER BY в спецификации окна определяет порядок записей лишь внутри окна.  Секционирование выполняется с помощью оператора PARTITION BY. Если нужно секционирование и упорядочивание, то оператор PARTITION BY должен располагаться до оператора ORDER BY";ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS row_num;;
ранжирующие;ранг записи;DENSE_RANK();;DENSE_RANK();;число;"вычисляет ранг записи в рамках указанного окна. Функция присваивает первой записи окна ранг, равный 1, и увеличивает его каждый раз, когда очередная запись в поле (или полях) упорядочивания содержит значение, отличное от значения предыдущей записи в том же поле. ";DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS place;;
ранжирующие;ранг записи с пропуском при повторении;RANK();;RANK();;число;"выполняет ранжирование в рамках указанного окна, при повторении рангов следующий ранг отбрасывает.";RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS place ;;
ранжирующие;разбивает на группы;NTILE();Кол-во групп;NTILE();Кол-во групп;число;"разбиения окна на заданное количество групп равного размера. если окно из n записей делится на k групп, то первые n % k (остаток от деления n на k) групп будут содержать ровно на 1 запись больше, чем остальные группы.";NTILE(3) OVER (ORDER BY id) AS group_number;;
оконные;среднее арифметическое ;AVG();поле;AVG();поле;число;"среднее арифметическое числовых значений, хранящихся в определенном поле окна. игнорируют значения NULL. возвращают значение 0.0, если применяются к нечисловым полям.";AVG(salary) OVER (PARTITION BY department) AS department_avg_salary;;
оконные;сумма;SUM();поле;SUM();поле;число;"Вычисляет сумму числовых значений, хранящихся в определенном поле окна. игнорируют значения NULL. возвращают значение 0.0, если применяются к нечисловым полям.";"SUM(salary) OVER () AS sum_salary, SUM(salary) OVER (PARTITION BY department) AS department_sum_salary";;
оконные;подсчет записей;COUNT();поле или *;COUNT();поле или *;число;"подсчета записей или непустых значений в поле. Если ее аргументом является звездочка (*), функция вычисляет количество записей в окне, если название поля — количество непустых значений в этом поле окна.";"COUNT(*) OVER (PARTITION BY department) AS employess_in_department, COUNT(salary) OVER (PARTITION BY department) AS employess_in_department_with_salary";;
оконные;минимум;MIN();поле;MIN();поле;значение;"вычисляет минимальное значение, хранящиеся в определенном поле окна, игнорируют значения NULL";MIN(salary) OVER (PARTITION BY department) AS department_min_salary;;
оконные;максимум;MAX();поле;MAX();поле;значение;"вычисляет максимальное значение, хранящиеся в определенном поле окна, игнорируют значения NULL";MAX(salary) OVER (PARTITION BY department) AS department_max_salary;;
оконные;значение первой записи окна;FIRST_VALUE();поле;FIRST_VALUE();поле;значение;"получения значения, которое содержится в определенном поле первой записи окна. Исп только с упорядоченными окнами.";FIRST_VALUE(salary) OVER (ORDER BY id) AS first_employee_salary;;
оконные;значение последней записи окна;LAST_VALUE();поле;LAST_VALUE();поле;значение;"получения значения, которое содержится в определенном поле последней записи окна. Если границы не определены то окно - от самой первой записи до текущей. Исп только с упорядоченными окнами.";LAST_VALUE(salary) OVER (ORDER BY id ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_employee_salary;;
оконные;значение n-ой записи окна;NTH_VALUE();"поле, номер записи";NTH_VALUE();"поле, номер записи";значение;"получения значения, которое содержится в определенном поле n-ой записи окна (начиная с 1).  Важно определение границ. Исп только с упорядоченными окнами. возвращает значение NULL если выходит за рамки ";;;
оконные;значения отстающей от текущей на n;LAG();"поле, номер записи, значение если функция выходит за рамки окна(если не указать - тогда NULL)";LAG();"поле, номер записи, значение если функция выходит за рамки окна(если не указать - тогда NULL)";значение;"получения значения, которое содержится в определенном поле записи окна, отстающей от текущей на n. Возвращает значение NULL, если пытается получить значение записи, выходящей за рамки окна. В случае выхода за рамки окна функция LAG() умеет возвращать не только NULL, но и любое другое значение. Для этого при вызове функции достаточно указать необходимое значение в качестве третьего аргумента. Полностью игнорирует границы окна. Используется только с упорядоченными окнами.";"LAG(salary, 1, 0) OVER (ORDER BY id) AS prev_employee_salary";;
оконные;значения опережающей текущую на n.;LEAD();"поле, номер записи, значение если функция выходит за рамки окна";LEAD();"поле, номер записи, значение если функция выходит за рамки окна";значение;"получения значения, которое содержится в определенном поле записи окна, опережающей текущую на n. Полностью игнорирует границы окна. Используется только с упорядоченными окнами.  ";"LEAD(salary, 1, 0) OVER (ORDER BY id) AS next_employee_salary";;
